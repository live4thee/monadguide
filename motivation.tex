\section{动机}

Haskell是一门纯函数式编程语言。用Haskell编写的函数是引用透明(referentially transparent)的。直觉上来说，它的意思是，对于相同的给定参数，函数总是返回同样的结果。更正式一点讲，给定一函数$f$，把对$f$的调用替换成调用结果，对程序的意义没有任何影响。所以，假如$f\ 3 = foo$，你可以安全的把所有出现$f\ 3$的地方都替换为$foo$，反之亦然。“纯函数式”意味着该语言不允许副作用(side-effects)，因为它会破坏引用透明。这样一来，函数的结果仅仅依赖于给定参数，也就是说，没有副作用。

Haskell中的函数和数学意义上的函数很相似，这使得对代码进行推理(reasoning)更加简单，而且相比于非引用透明的代码，编译器很多情况下可以做出更好的优化。进一步讲，求值顺序变得毫无意义。对于表达式$(x,y)$，编译器可以自由选择先对$x$还是$y$进行求值。如果其中一个值并不需要，甚至可以忽略对其求值。这带来了灵活性(如果仅仅是使用其有限部分，你可以拥有无穷的数据结构或者计算\footnote{译者注：比如Scheme中的Lazy List})和高性能。最后，编译器还可以选择获得结果的任意执行路径，从而导致Haskell程序具有近乎疯狂的可并行性，因为编译器可以同时并行执行多条路径。比如，它可以决定同时计算出$x$和$y$。

与引用透明相反的是引用模糊(referentially opaque)。一个引用模糊的函数有多重含义，甚至对于相同参数会返回不同结果，而标准示例便是随机数生成器。在大多数程序语言中，随机数函数根本就不需要任何参数。对于一个仅仅向屏幕打印出固定文本，并且总是返回$0$的函数来讲，虽然有点违反直觉，它也是个引用模糊的函数。因为你无法在不改变程序意义的条件下，把对该函数的调用全部替换成$0$。

正如上文指出，一个明显的结果是Haskell中无法写出一个不带参数的返回伪随机数的$random$函数，因为这会破坏引用透明。事实上，Haskell中一个不带参数的函数根本就不是函数，它仅仅是个值。这个问题存在很多简单的解决方案，其中一个方法是在输入参数中引入一个状态值，函数返回伪随机数的同时也返回一个新的状态。

\begin{lstlisting}
random :: RandomState -> (Int, RandomState)
\end{lstlisting}

另一个方法是用一个参数作为初始种子值，然后返回一个包含伪随机数的无穷表。利用上面定义的$random$，该函数可以简单的实现为：

\begin{lstlisting}
randomList :: RandomState -> [Int]
randomList state = x : randomList newState
  where
    (x, newState) = random state
\end{lstlisting}

由上述示例我们得出，确定性序列的的问题可以轻松搞定，而且相比于命令式语言中常见的引用模糊的$random$函数，我们得到一个有用的特性：状态可以序列号，并且简单地回溯到先前的状态，或者向两个函数注入相同的伪随机数序列。

如何处理输入输出呢？一门通用语言如果不能开发用户接口或者读文件几乎毫无用处。我们终究想要从键盘读取输入或者向终端打印一些东西。假想遇到一个$getChar$函数，它从终端读取单个字符：

\begin{lstlisting}
getChar :: Char
\end{lstlisting}

你会发现该函数违背了引用透明，因为每次调用该函数都可能返回一个不同的字符。前面已经看到，该问题可以通过引入一个状态变量解决。但我们需要什么状态？终端的状态吗？嗯，让我们使之更通用一点，传入宇宙的状态，假设它类型是$Universe$。这样我们可以修改$getChar$函数的类型，并且实现一个$twoChars$函数以展现如何使用$getChar$：

\begin{lstlisting}
getChar :: Universe -> (Char, Universe)

twoChars :: Universe -> (Char, Char, Universe)
twoChars world0 = (c1, c2, world2)
  where
    (c1, world1) = getChar world0
    (c2, world2) = getChar world1
\end{lstlisting}

我们似乎已经找到一种有效的解决方案来应付这种问题 -- 只要传递一个状态变量即可。但该方法有个问题。首先，当然，因为需要额外传递状态，程序员需要付出更多的击键；其次，更重要的是，像随机函数$random$这样的有用而必要的功能，却成为读取键盘和写终端之类严格非纯(strictly impure)操作的主要障碍：

\begin{lstlisting}
strangeChars :: Universe -> (Char, Char)
strangeChars world = (c1, c2)
  where
    (c1, _) = getChar world
    (c2, _) = getChar world
\end{lstlisting}

让我们试着理解以上代码的意图究竟是什么。我们从宇宙中，也就是世界的状态， 读取字符$c1$，同样的状态里还读取了字符$c2$，于是我们其实时光旅行到了过去。但这是何时发生的呢？首先，计算$c1$和$c2$的顺序是未定义的，因为我们没有像在$twoChars$函数里那样序列化世界的状态。 其次，$strangeChars$没有返回更新后的宇宙状态，当数据读出之后，这事儿被忘记得一干二净\footnote{译者注：因为世界的状态没有更新}，就像压根儿没发生过一样。

结论：我们可以无痛地序列化伪随机数生成器的状态，对于宇宙的状态却无能为力\footnote{译者注：伪随机数生成器可以通过公式(如线性同余算法)由上一个数值计算出下一个值，而对于宇宙状态来说，是没有公式可以描述的。}。该问题存在一些解决方案。比如，纯函数式语言$Clean$，它使用了一个$uniqueness$类型，基本上就像上文描述的$universe$那样。但是，该语言会检测并阻止任何对世界状态的并行访问的尝试，从而保证了其基于显式状态传递的I/O一致性。Haskell则采用了另一种方案。它引入了一种范畴论中称之为单子的结构，而不是显式地传递世界的状态。