\section{动机}

Haskell是一门纯函数式编程语言。用Haskell编写的函数是引用透明(referentially transparent)的。直觉上来说，它的意思是，对于相同的给定参数，函数总是返回同样的结果。更正式一点讲，给定一函数$f$，把对$f$的调用替换成调用结果，对程序的意义没有任何影响。所以，假如$f\ 3 = foo$，你可以安全的把所有出现$f\ 3$的地方都替换为$foo$，反之亦然。“纯函数式”意味着该语言不允许副作用(side-effects)，因为它会破坏引用透明。这样一来，函数的结果仅仅依赖于给定参数，也就是说，没有副作用。

Haskell中的函数和数学意义上的函数很相似，这使得对代码进行推理(reasoning)更加简单，而且相比于非引用透明的代码，编译器很多情况下可以做出更好的优化。进一步讲，求值顺序变得毫无意义。对于表达式$(x,y)$，编译器可以自由选择先对$x$还是$y$进行求值。如果其中一个值并不需要，甚至可以忽略对其求值。这带来了灵活性(如果仅仅是使用其有限部分，你可以拥有无穷的数据结构或者计算\footnote{译者注：比如Scheme中的Lazy List})和高性能。最后，编译器还可以选择获得结果的任意执行路径，从而导致Haskell程序具有近乎疯狂的可并行性，因为编译器可以同时并行执行多条路径。比如，它可以决定同时计算出$x$和$y$。

与引用透明相反的是引用模糊(referentially opaque)。一个引用模糊的函数有多重含义，甚至对于相同参数会返回不同结果，而标准示例便是随机数生成器。在大多数程序语言中，随机数函数根本就不需要任何参数。对于一个仅仅向屏幕打印出固定文本，并且总是返回$0$的函数来讲，虽然有点违反直觉，它也是个引用模糊的函数。因为你无法在不改变程序意义的条件下，把对该函数的调用全部替换成$0$。

正如上文指出，一个明显的结果是Haskell中无法写出一个不带参数的返回伪随机数的$random$函数，因为这会破坏引用透明。事实上，Haskell中一个不带参数的函数根本就不是函数，它仅仅是个值。这个问题存在很多简单的解决方案，其中一个方法是在输入参数中引入一个状态值，函数返回伪随机数的同时也返回一个新的状态。

\begin{lstlisting}
random :: RandomState -> (Int, RandomState)
\end{lstlisting}

另一个方法是用一个参数作为初始种子值，然后返回一个包含伪随机数的无穷表。利用上面定义的$random$，该函数可以简单的实现为：

\begin{lstlisting}
randomList :: RandomState -> [Int]
randomList state = x : randomList newState
  where
    (x, newState) = random state
\end{lstlisting}

由上述示例我们得出，确定性序列的的问题可以轻松搞定，而且相比于命令式语言中常见的引用模糊的$random$函数，我们得到一个有用的特性：状态可以序列号，并且简单地回溯到先前的状态，或者向两个函数注入相同的伪随机数序列。

如何处理输入输出呢？一门通用语言如果不能开发用户接口或者读文件几乎毫无用处。我们终究想要从键盘读取输入或者向终端打印一些东西。假想遇到一个$getChar$函数，它从终端读取单个字符：

\begin{lstlisting}
getChar :: Char
\end{lstlisting}

你会发现该函数违背了引用透明，因为每次调用该函数都可能返回一个不同的字符。前面已经看到，该问题可以通过引入一个状态变量解决。但我们需要什么状态？终端的状态吗？嗯，让我们使之更通用一点，传入宇宙的状态，假设它类型是$Universe$。这样我们可以修改$getChar$函数的类型，并且实现一个$twoChars$函数以展现如何使用$getChar$：

\begin{lstlisting}
getChar :: Universe -> (Char, Universe)

twoChars :: Universe -> (Char, Char, Universe)
twoChars world0 = (c1, c2, world2)
  where
    (c1, world1) = getChar world0
    (c2, world2) = getChar world1
\end{lstlisting}
