\section{隐式状态}
关于状态，在第二节，我已经谈了许多。状态在多数其他语言中相当基础且不可或缺，以至于你可能从未困扰于意识到它的
存在。通常，命令式模型的程序设计将整个程序看做一个被持续修改的巨大的状态。这没啥可惊讶的，因为多数语言都是被
建模成反映图灵机计算模型。Haskell则（且必须是）另辟蹊径。

那首先什么是状态？它是你的程序或者程序中的某个部分可以在其生命期中可以访问并修改的一个环境。要将其纳入纯
函数式编程模型并保持引用透明，状态必须是显式的，比如将其作为一个函数参数。我们再次看看第一节中的$random$
函数式如何工作的：

\begin{lstlisting}
random :: RandomState -> (Int, RandomState)
\end{lstlisting}

在非纯(non-pure)语言中，一个返回随机数的函数可以避免到处传递状态，比如，通过使用全局变量。Haskell中情况则不是
这样。当然，这是一份Monad教程，假如Monad不能帮助解决该问题，我也不会提到状态。:-)

确实，Monad真的可以搞定它。事实上，对于所有和状态相关的事物，monad是个美德。