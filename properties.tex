\section{Monad的属性}
\subsection{Monad定律}
首先，要成为Monad，它必须遵守三个法则。除了范畴论的需要外，这三个法则也确实有意义：
\begin{enumerate}
\item $return\ x >>=  f \equiv f\ x$
\item $c >>= return \equiv c$
\item $c >>= (\backslash{}x \rightarrow f\ x >>= g) \equiv (c >>= f) >>= g$
\end{enumerate}

从绑定的角度来讲，第一条法则要求$return$是个左幺元。简单来说，它的意思是，$return$将$x$变成一个求值结果是
$x$的计算，然后绑定至消费者函数$f$，这个过程等同于直接用$x$调用$f$。听起来很明显，不是吗？

从绑定的角度来讲，第二条法则要求$return$是个右幺元。意思是，将一个源计算的结果$x$绑定至$return$函数（它会
给出一个返回结果$x$的计算）等同于直接给出源计算(求值为$x$)。这应该和上一条法则一样显而易见。

第三条法则要求绑定子函数$>>=$满足结合律。要明白该法则，我们先考虑一个返回给定整数三十次方根的计算（如果
没有结果则返回$Nothing$）。你可以先求平方根，再依次求立方根和五次方根：

\begin{lstlisting}
i30throot :: Integer -> Maybe Integer
i30throot x = isqrt x >>= icbrt >>= i5throot
\end{lstlisting}

你可以首先得到求六次方根的计算$(isqrt\ x >>= icbrt)$，然后将其结果传递给$i5throot$求五次方根；或者你可以先求
平方根$(isqrt x)$，然后将其结果传递给求十五次方根的计算$(\backslash{}y \rightarrow icbrt\ y >>= i5throot)$。第
三条法则要求这两种计算的最终结果是相同的。

\subsection{辅助函数}
前面讲过，上面给出的$Monad$类并不完整。它还包含两个成员函数，$(>>)$和$fail$：

\begin{lstlisting}
class Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b -> m b
  fail   :: String -> m a
\end{lstlisting}

假如一个计算的结果没有意义，或者并不需要，用$(>>)$函数是非常方便的。你不必在实例化该函数时提供它的定义，
因为它可以简单从$(>>=)$函数推导而来，下面便是其默认定义：

\begin{lstlisting}
a >> b = a >>= const b
\end{lstlisting}

假设有$a$和$b$两个计算，并且你想获得一个计算，它是运行$a$和$b$后的结果，且该计算的求值结果便是$b$的结
果，而忽略$a$。通过绑定子函数，你可以撰写代码如$a >>= \backslash\_ \rightarrow b$，或者$ a >>= const b$。
有了$(>>)$函数后我们可以方便的写为$a >> b$。本节后面将会讲到隐式状态，此时$(>>)$函数将变得很有用。

该函数常常用在求值为类型$()$的计算中。单元类型$()$常用于求值结果没有意义的情况。和$\bot$不同的是，$()$类型
只有一个值，也就是$()$。该单元类型类似于C语言中的$void$类型，只是C的$void$类型没有取值。

$fail$函数接受一个出错字符串作为参数，返回一个代表失败的计算，而且该计算中很有可能包含给定出错字符串。
$fail$函数的默认定义是返回一个$\bot$计算，因此调用该函数将会终止程序。后面会讲到f该函数的用处，我们现在
可以先忽略它。

\subsection{Monadic函数以及Monadic计算的解释}
$return$和我们的$isqrt$这样一类函数返回的计算，或者通过Monad构造函数如$Just$得到的计算，同普通值在本质上
有些许差别。前面我曾说，可以将$monadic\ value$看成是$computation$而非普通$value$，其背景如下文。

考虑$Maybe$，一个monadic值$Just 3$并不立马等同于普通值$3$。它是一个返回$3$的计算。一眼看起来这有点不
自然，毕竟我们已经得到了值$3$，还是先试着解释绑定子函数$(>>=)$的行为吧。该函数接受一个源计算，和一个
消费者monadic函数，并将源计算的结果绑定为消费者函数的参数，而\textbf{绑定}的意义则由具体Monad解释。
由此可以得出一个内在思想：在一个计算中使用另一个计算的结果，中间不需要某个记号去运行该计算。

重要的是，只要你不请求该结果，中间就不会有结果产生，存在的只是计算本身。我们如何请求一个计算的结果呢？
最明显的方法是使用相应的monad中的绑定子函数。但你刚刚知道，绑定子函数并不产生值，它只给出一个计算，
从中取出结果并使用之只是该计算的一部分。我们如何从一个计算中取出本身并非计算的的真正最终结果呢？
换句话说，怎样运行一个计算呢？

\subsection{陷入一个Monad}
你已经看见，monad是表示计算的容器。你可以创建求得某个值的计算，可以绑定该计算结果给monadic函数。但我们
也想得到最终值，比如我们想从$Just 3$中取出$3$。至今为止，我们接触到的monad都是有构造函数的，比如$Maybe$
和列表，所以你可以通过模式匹配甚至等式从一个monadic值中解出最终值。

即使那些构造函数（$Just$，$Nothing$，$[\ ]$，$(:)$）是未知的，也会有一些辅助函数用于从计算中求得结果，视不同的
Monad这些函数看起来也许会有些差别。比方说，对于列表，我们有$head$和$last$函数。而对于$Maybe$，则有函数
$fromJust$和$fromMaybe$。

但万一你既不知道这些构造函数，而且也没有辅助函数可用呢？此时确实没有任何办法可以从一个计算中结出结果。
这一点很重要，因为它使得我们可以用monad做一些有趣的事情。该属性是不用到处传递世界的状态就可以与外部世界
交互的基础 -- 它也正是$IO$ monad的基础，我们很快就会聊到它。
