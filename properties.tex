\section{Monad的属性}
\subsection{Monad定律}
首先，要成为Monad，它必须遵守三个法则。除了范畴论的需要外，这三个法则也确实有意义：
\begin{enumerate}
\item $return\ x >>=  f \equiv f\ x$
\item $c >>= return \equiv c$
\item $c >>= (\backslash{}x \rightarrow f\ x >>= g) \equiv (c >>= f) >>= g$
\end{enumerate}

从绑定的角度来讲，第一条法则要求$return$是个左幺元。简单来说，它的意思是，$return$将$x$变成一个求值结果是$x$的计算，然后绑定至消费者函数$f$，这个过程等同于直接用$x$调用$f$。听起来很明显，不是吗？

从绑定的角度来讲，第二条法则要求$return$是个右幺元。意思是，将一个源计算的结果$x$绑定至$return$函数（它会给出一个返回结果$x$的计算）等同于直接给出源计算(求值为$x$)。这应该和上一条法则一样显而易见。

第三条法则要求绑定子函数$>>=$满足结合律。要明白该法则，我们先考虑一个返回给定整数三十次方根的计算（如果没有结果则返回$Nothing$）。你可以先求平方根，再依次求立方根和五次方根：

\begin{lstlisting}
i30throot :: Integer -> Maybe Integer
i30throot x = isqrt x >>= icbrt >>= i5throot
\end{lstlisting}

你可以首先得到求六次方根的计算$(isqrt\ x >>= icbrt)$，然后将其结果传递给$i5throot$求五次方根；或者你可以先求平方根$(isqrt x)$，然后将其结果传递给求十五次方根的计算$(\backslash{}y \rightarrow icbrt\ y >>= i5throot)$。第三条法则要求这两种计算的最终结果是相同的。

\subsection{辅助函数}
前面讲过，上面给出的$Monad$类并不完整。它还包含两个成员函数，$(>>)$和$fail$：

\begin{lstlisting}
class Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b -> m b
  fail   :: String -> m a
\end{lstlisting}

假如一个计算的结果没有意义，或者并不需要，用$(>>)$函数是非常方便的。你不必在实例化该函数时提供它的定义，因为它可以简单从$(>>=)$函数推导而来，下面便是其默认定义：

\begin{lstlisting}
a >> b = a >>= const b
\end{lstlisting}

假设有$a$和$b$两个计算，然后你想得到一个计算，它是运行$a$和$b$后的结果，该计算的求值结果便是$b$的结果，而忽略$a$。通过绑定子函数，你可以撰写代码如$a >>= \backslash\_ \rightarrow b$，或者$ a >>= const b$。有了$(>>)$函数后我们可以方便的写为$a >> b$。本节后面将会讲到隐式状态，此时$(>>)$函数将变得很有用。

该函数常常用在求值为类型$()$的计算中。单元类型$()$常用于求值结果没有意义的情况。和$\bot$不同的是，$()$类型只有一个值，也就是$()$。该单元类型类似于C语言中的$void$类型，只是C的$void$类型没有取值。

$fail$函数接受一个出错字符串作为参数，返回一个代表失败的计算，而且该计算中很有可能包含给定出错字符串。$fail$函数的默认定义是返回一个$\bot$计算，因此调用该函数将会终止程序。后面会讲到该函数的用处，我们现在可以先忽略它。
